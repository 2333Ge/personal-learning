- 首先判断缓存，不能利用本地缓存时走以下过程（提一嘴[[强缓存与协商缓存]]）
- 根据五层网络模型从上至下看：
	- 应用层：链接解析，构建HTTP消息，进行 [[域名解析]]；
	- 传输层：[[TCP 三次握手]]建立连接、HTTPS 请求额外进行[[TLS 协商]]；
	- 网络层：
		- 同一子网直接发送，不同子网发送给网关；
		- [[ARP协议]]根据IP查找MAC地址；
		- [[ICMP协议]]传输出错报告控制信息；
	- 数据链路层、物理层：数据链路转化为电信号；
- 资源请求回来以后浏览器开始解析，构建 [[DOM]] 、 [[CSSOM]]
	- 从上到下扫描，构建[[DOM]]，遇到script标签会堵塞，除非有async/defer属性
	- [[预加载扫描器]]会解析可用内容并请求高优先级资源
	- 构建[[CSSOM]]
- 渲染，包括样式、布局、绘制，在某些情况下还包括合成
	- 样式：将 [[DOM]] 和 [[CSSOM]] 组合成渲染树
	- 布局：确定呈现树中所有节点的尺寸和位置
	- 绘制：将元素的每个可见部分绘制到屏幕上
	- 合成：文档的各个部分以不同的层绘制，相互重叠时，进行合成
- 交互：如果有正在加载的JS可能无法响应
- ## 从进程、线程的角度
- ```mathematica
  [用户输入 URL]
      ↓
  [浏览器主进程 UI 线程]
      ↓
  [网络进程 网络线程] ←→ DNS 服务器
      ↓
  建立 TCP 连接，发送 HTTP 请求
      ↓
  接收响应，传给渲染进程
  
  [渲染进程 Main Thread]
    ├─ HTML 解析 → 构建 DOM
    ├─ CSS 解析 → 构建 CSSOM，计算样式
    ├─ javascript 解析／执行（会阻塞）
    ├─ 构建 Render Tree
    ├─ 布局/Layout（计算几何位置）
    └─ 绘制/Paint → 生成绘制命令
  
  ↘
  [预加载扫描线程 (Preload Scanner)]
    • 并行扫描 HTML，预先请求 CSS、图片、JS 等资源 :contentReference[oaicite:1]{index=1}
  
  [渲染进程 Compositor Thread]
    • 接收绘制命令，生成层（Layer Tree）
    • 调度给 Raster Thread 或 GPU 进程进行光栅化合成 :contentReference[oaicite:2]{index=2}
  
  [GPU / Raster Threads]
    • 进行纹理绘制、图层合成，最终呈现在屏幕上 :contentReference[oaicite:3]{index=3}
  
  ```
- ## 参考文章
- [小林coding：键入网址到网页显示，期间发生了什么](https://www.xiaolincoding.com/network/1_base/what_happen_url.html)
- [MDN：渲染页面：浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)
- [思否：带你了解浏览器原理](https://segmentfault.com/a/1190000042928793)
-