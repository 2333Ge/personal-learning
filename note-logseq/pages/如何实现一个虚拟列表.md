## 简单版
- **核心思想**：只渲染「可视区域 + buffer 区域」元素，未可见部分不渲染，但通过一个撑高的容器保持滚动条正确
- ### 实现步骤
  
  1. **固定项高度**：如每项 `itemHeight = 50`
  2. **计算可见范围**：
	- `startIndex = scrollTop / itemHeight`
	- `endIndex = startIndex + visibleCount + buffer`
- 3. **渲染可见项并定位**：
	- 使用 `absolute` + `top = index * itemHeight`
- 4. **容器撑高**：用一个高为 `total * itemHeight` 的外层 div 占位
- ### 升级项
- **动态高度支持**：使用 `ResizeObserver` 或 `ref` 获取每项真实高度，缓存高度列表。
- **懒加载更多数据**（infinite scroll）：当滚动接近底部，触发加载更多数据。
- **缓存已渲染项**：避免重复计算。
- **使用节流 / 防抖优化 onScroll**。
- ## 动态高度支持
- 1. 初始依然通过估算高度设置整体容器，确保滚动条基本正确
- 2. 存一个真实高度map
- 3. 滑动后估算可视区域元素，渲染并记录真实高度，设置top距离
- 4. 同时渲染领界元素：避免有计算失误没渲染出来的元素或者继续滚动页面跳动的情况
- ### 优化项目：
- **智能估算高度**：
	- 按类型/内容长度/结构字段智能估算每项高度；
	- 以「已测量项的平均高度」动态更新 estimatedItemHeight。
- **平滑过渡**：如果跳动无法避免用 requestAnimationFrame 或动画等方式平滑过渡，优化体验。
- **保持锚点位置**（高阶优化）：视口中 anchor 元素位置不变，即使偏移修正
- ### 保持锚点位置
- 🌰举例：你滚动到第 50 项，正好出现在视口顶部。
  此时第 20~49 项中有几项因为图片加载变高，或者因为数据变化被重新渲染。
  正常情况：第 50 项会被「推下去」，你视口内容发生跳动。
- **锚点优化：** 虚拟列表会：
	- 记录第 50 项在滚动前的 `top = 0`
	- 更新前面项高度后，自动**调整 scrollTop**，让第 50 项仍处于原来的视觉位置
- ## 参考
- [chatgpt：如何实现虚拟列表及常见问题](https://chatgpt.com/share/688c3639-ce10-8012-8cde-c27aad8b8b35)
-