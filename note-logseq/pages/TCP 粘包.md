- [[TCP]] 是面向**字节流**的协议，用户消息通过TCP协议传输时，可能被操作系统分组成多个TCP报文，如果接收方不知道发送方的消息长度，即不知道消息的边界时无法读出一个完整的用户消息。
- 我们不能认为一个用户消息对应一个TCP报文，故TCP 是面向字节流的协议（[[UDP]]是面向报文的协议）
- 如何解决粘包问题，即解决如何区分消息边界的问题，常见的三种分包方式：
	- 固定消息长度（如[[HTTP]] `Content-Length`）
	- 特殊字符（如[[HTTP]] 回车符换行符确定Header边界）
	- 自定义消息结构
- ## question
- TCP协议、TCP 粘包属于传输层，传输层的问题为什么要交给应用层来解决？TCP协议为什么不能设置边界？
	- 字节流的设计方式可以让数据持续稳定的传输，不需要频繁中断来界定消息；
	- 应用层更了解自己的消息结构；应用层可采用更适合自身的方式解决，
	- 如对实时性要求很高的应用，传输层的统一解决方案引入的额外机制可能会导致传输延迟增加；
- TCP 粘包后如何拆包，应用层拆包？如果是应用层拆包，拿HTTP消息举例，如果A、B两条消息在一个TCP报文里面，后面是如何拆包的？
	- 基于消息长度：应用层接收端从TCP缓冲区度数据，当读取到一定数据后，如前4字节有消息长度字段，拿到Length后，根据Length读取Length字节数据，后续数据就属于下一个消息了
	- 其他方式：类似，应用层知道一个消息的边界
- 粘包可能粘不同协议的包吗，如HTTP+SMTP
	- 可能性极小，因为不同的协议会建立独立的TCP连接，即使在同一个TCP连接中，协议本身结构也不同，可以区分出来
- ## 参见
- [小林coding：如何理解TCP是面向字节流的协议](https://xiaolincoding.com/network/3_tcp/tcp_stream.html)
- [豆包AI](https://www.doubao.com/thread/wd7f60a5209e3a4cb)
-