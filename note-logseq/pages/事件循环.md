- 解释：JS 引擎通过事件循环机制，在单线程环境下实现了非阻塞的异步执行，这是浏览器环境下处理用户交互、网络请求等异步任务的基础。
- 关键点：#宏任务 、 #微任务 、 调用栈 消息队列。
- ![runtime-environment-diagram.png](../assets/runtime-environment-diagram_1749106866640_0.png)
- 主要组成部分：
	- 调用栈：存储函数调用信息（后进先出）
	- 任务队列
		- 宏任务：
			- `setTimeout`、`setInterval`、I/O 操作、事件绑定
			- nodejs中：`setImmediate`
		- 微任务：
			- [[promise]] 的 `then`、`catch` 和 `finally`、`queueMicroTask()`
			- nodejs中：`process.nextTick`（优先级最高的微任务）
	- **事件循环线程** ：持续检查调用栈和任务队列的协调机制
- 事件循环执行顺序
	- 1. **执行全局同步代码**（属于第一个宏任务）
	- 2. **检查微任务队列**：
		- 执行所有微任务（直到队列清空）
		- 包括Promise.then、MutationObserver等
	- 3. **UI渲染**（浏览器环境）：
		- 执行requestAnimationFrame回调
		- 执行样式计算、布局、绘制
	- 4. **从宏任务队列取出一个任务执行**：
		- 包括setTimeout、setInterval、I/O、UI交互事件等
	- **重复步骤2-4**
- ## 尝试回答
- 答案见末尾
- 题目一
  ```JavaScript
  async function asyncFn() {
    console.log('1');
    await Promise.resolve().then(() => {
        console.log('2');
    });
    console.log('3');
  }
  
  console.log('4');
  
  asyncFn();
  
  setTimeout(() => {
    console.log('5');
  }, 0);
  
  console.log('6');
  ```
- 题目二
  ```JavaScript
    console.log("start");
  
    async function a1() {
      console.log(1);
      await a2();
      console.log(2);
      await new Promise((resolve) => {
        console.log('a1 new')
      }).then(() => {
        console.log('a1 then')
      })
      console.log('a1 last')
    }
    async function a2() {
      console.log(3);
    }
    a1();
  
    setTimeout(() => {
      console.log("setTimeout");
    }, 0);
  
    Promise.resolve()
      .then(() => {
        console.log("promise1");
      })
      .then(() => {
        console.log("promise2");
      });
  
    console.log("end");
  ```
- 答案：
- ```JavaScript
  // 题目一
  4
  1
  6
  2
  3
  5
  // 题目二，注意没有resolve的情况
  start
  1
  3
  end
  2
  a1 new
  promise1
  promise2
  setTimeout
  ```
- ### async 中的同步代码
- 上例题目二1、2、3的打印容易出错
  > 异步函数的函数体可以被看作是由零个或者多个 await 表达式分割开来的。从顶层代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。因此，不包含 await 表达式的异步函数是同步运行的。然而，如果函数体内包含 await 表达式，则异步函数就一定会异步完成。参考[MDN： async function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function)
  
  结合MDN的描述进行分析，`a2` 函数虽然被声明为 `async`，但它**内部没有 `await` 表达式**，因此根据 MDN 的说明：
  > 不包含 await 表达式的异步函数是同步运行的
  
  所以 `a2` 中的 `console.log(3)` 是**同步执行**的。
  
  让我们追踪整个执行过程：
  1. `a1()` 被调用
  2. 执行 `console.log(1)` - 同步
  3. 执行 `await a2()` - 这里会调用 `a2()``
  4. a2()` 虽然是 async 函数，但因为没有 await，所以 `console.log(3)` **同步执行**`
  5. a2()` 返回一个已解决的 Promise`
  6. await` 让 `a1` 函数暂停，`console.log(2)` 会在下一个微任务中执行
- 理解上面的流程后做个题目二的变式
- 题目二-二
  ```JavaScript
  console.log("start");
  
  async function a1() {
    console.log(1);
    await a2();
    console.log(2);
    await a3();
    await a4();
  }
  async function a2() {
    console.log(3);
    a2_2();
  }
  
  async function a2_2() {
    console.log("a2_2");
  }
  
  async function a3() {
    console.log("a3");
  }
  async function a4() {
    console.log("a4");
  }
  a1();
  
  setTimeout(() => {
    console.log("setTimeout");
  }, 0);
  
  Promise.resolve()
    .then(() => {
      console.log("promise1");
    })
    .then(() => {
      console.log("promise2");
    });
  
  console.log("end");
  ```
- 答案：
  ```JavaScript
  start
  1
  3
  a2_2
  end
  2
  a3
  promise1
  a4
  promise2
  setTimeout
  ```
- ## my question
- 微任务的执行时机，是在宏任务栈执行完毕，还是在宏任务栈的其中一个任务执行完毕后开始
	- 其中一个
- ## 相关链接
- [并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Event_loop)
- [深入：微任务与 JavaScript 运行时环境](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth)
- [在 JavaScript 中通过 queueMicrotask() 使用微任务](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide)
- [豆包AI总结](https://www.doubao.com/thread/w9050ce7ec3fdf475)
- [MDN： async function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function)