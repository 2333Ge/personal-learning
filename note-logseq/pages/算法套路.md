# 常见算法分类及使用场景
- ## 1. **搜索算法**
- ### 二分查找 (Binary Search)
- **何时使用**：有序数组中查找元素
- **特点**：O(log n) 时间复杂度
- ### 深度优先搜索 (DFS)
- **何时使用**：树/图的遍历、路径查找、连通性判断
- **特点**：递归或栈实现，适合探索所有可能路径
- ### 广度优先搜索 (BFS)
- **何时使用**：最短路径、层次遍历、最小步数问题
- **特点**：队列实现，适合求最优解
- ## 2. **排序算法**
- ### 快速排序 (Quick Sort)
- **何时使用**：一般情况下的高效排序
- **特点**：平均 O(n log n)，原地排序
- ### 归并排序 (Merge Sort)
- **何时使用**：需要稳定排序、外部排序
- **特点**：稳定 O(n log n)，需要额外空间
- ### 堆排序 (Heap Sort)
- **何时使用**：需要 O(1) 空间的 O(n log n) 排序
- **特点**：不稳定但空间效率高
- ## 3. **动态规划 (DP)**
- **何时使用**：最优化问题、有重叠子问题和最优子结构
- **经典问题**：背包问题、最长公共子序列、爬楼梯
- ## 4. **贪心算法 (Greedy)**
- **何时使用**：局部最优能导致全局最优的问题
- **经典问题**：活动选择、霍夫曼编码、最小生成树
- ## 5. **回溯算法 (Backtracking)**
- **何时使用**：需要穷举所有可能解的问题
- **经典问题**：N皇后、全排列、数独求解
- ## 6. **分治算法 (Divide and Conquer)**
- **何时使用**：问题可以分解为相似的子问题
- **经典问题**：归并排序、快速排序、大整数乘法
- ## 7. **图算法**
- ### Dijkstra算法
- **何时使用**：单源最短路径（非负权重）
- **特点**：贪心策略，适合稠密图
- ### Floyd算法
- **何时使用**：所有点对之间的最短路径
- **特点**：动态规划，O(n³) 时间复杂度
- ### 拓扑排序
- **何时使用**：有向无环图的线性排序
- **应用**：课程安排、依赖关系处理
- ## 8. **字符串算法**
- ### KMP算法
- **何时使用**：字符串模式匹配
- **特点**：O(m+n) 时间复杂度，避免重复比较
- ### Trie树
- **何时使用**：前缀匹配、自动补全
- **特点**：空间换时间，快速前缀查询
- ## 选择算法的一般原则
  
  1. **数据规模**：小数据用简单算法，大数据考虑复杂度
  2. **数据特性**：有序/无序、稀疏/稠密
  3. **空间限制**：内存是否充足
  4. **稳定性要求**：是否需要保持相等元素的相对顺序
  5. **实时性要求**：是否需要在线算法
  
  根据具体问题特点选择最适合的算法是关键！